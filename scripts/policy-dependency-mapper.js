#!/usr/bin/env node

/**
 * Policy Dependency Mapping Script
 * 
 * This script creates a visual dependency map of RLS policies to identify
 * circular references and complex dependency chains.
 * 
 * Requirements: 2.1, 2.2
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class PolicyDependencyMapper {
  constructor() {
    this.dependencies = new Map();
    this.policies = new Map();
    this.functions = new Map();
    this.circularPaths = [];
  }

  /**
   * Load the analysis report generated by policy-analysis.js
   */
  loadAnalysisReport() {
    const reportPath = path.join(__dirname, '..', 'policy-analysis-report.json');
    
    if (!fs.existsSync(reportPath)) {
      console.error('Policy analysis report not found. Please run policy-analysis.js first.');
      process.exit(1);
    }

    const report = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
    
    // Extract table dependencies
    for (const [tableName, analysis] of Object.entries(report.tableAnalysis)) {
      this.dependencies.set(tableName, analysis.dependencies || []);
      this.policies.set(tableName, analysis.policies || []);
    }

    console.log(`Loaded analysis for ${this.dependencies.size} tables`);
    return report;
  }

  /**
   * Extract function definitions that could create circular references
   */
  extractFunctions() {
    const migrationsDir = path.join(__dirname, '..', 'supabase', 'migrations');
    const files = fs.readdirSync(migrationsDir)
      .filter(file => file.endsWith('.sql'))
      .sort();

    const functionRegex = /CREATE\s+(?:OR\s+REPLACE\s+)?FUNCTION\s+(?:public\.)?(\w+)\s*\([^)]*\)[^$]*\$([^$]*)\$/gis;

    for (const file of files) {
      const filePath = path.join(migrationsDir, file);
      const content = fs.readFileSync(filePath, 'utf8');
      
      let match;
      while ((match = functionRegex.exec(content)) !== null) {
        const [, functionName, functionBody] = match;
        
        // Extract table references from function body
        const tableRefs = this.extractTableReferences(functionBody);
        
        this.functions.set(functionName, {
          name: functionName,
          body: functionBody.trim(),
          tableReferences: tableRefs,
          file: file
        });
      }
    }

    console.log(`Found ${this.functions.size} functions`);
  }

  /**
   * Extract table references from SQL text
   */
  extractTableReferences(sql) {
    const references = new Set();
    const patterns = [
      /FROM\s+(?:public\.)?(\w+)/gi,
      /JOIN\s+(?:public\.)?(\w+)/gi,
      /EXISTS\s*\(\s*SELECT[^)]*FROM\s+(?:public\.)?(\w+)/gi,
      /IN\s*\(\s*SELECT[^)]*FROM\s+(?:public\.)?(\w+)/gi,
    ];

    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(sql)) !== null) {
        references.add(match[1]);
      }
    }

    return Array.from(references);
  }

  /**
   * Find circular dependencies using depth-first search
   */
  findCircularDependencies() {
    const visited = new Set();
    const recursionStack = new Set();
    const paths = new Map();

    const dfs = (table, path = []) => {
      if (recursionStack.has(table)) {
        // Found a cycle
        const cycleStart = path.indexOf(table);
        const cycle = path.slice(cycleStart).concat([table]);
        this.circularPaths.push({
          cycle: cycle,
          type: 'table_dependency',
          description: `Table dependency cycle: ${cycle.join(' â†’ ')}`
        });
        return;
      }

      if (visited.has(table)) {
        return;
      }

      visited.add(table);
      recursionStack.add(table);
      const currentPath = [...path, table];
      paths.set(table, currentPath);

      const dependencies = this.dependencies.get(table) || [];
      for (const dep of dependencies) {
        dfs(dep, currentPath);
      }

      recursionStack.delete(table);
    };

    // Check table dependencies
    for (const table of this.dependencies.keys()) {
      if (!visited.has(table)) {
        dfs(table);
      }
    }

    // Check function-table circular references
    this.findFunctionCircularReferences();
  }

  /**
   * Find circular references involving functions
   */
  findFunctionCircularReferences() {
    for (const [functionName, functionInfo] of this.functions) {
      for (const tableRef of functionInfo.tableReferences) {
        // Check if any policies on the referenced table call this function
        const tablePolicies = this.policies.get(tableRef) || [];
        
        for (const policy of tablePolicies) {
          const policyText = `${policy.usingClause || ''} ${policy.withCheckClause || ''}`;
          
          if (policyText.includes(`${functionName}(`)) {
            this.circularPaths.push({
              cycle: [functionName, tableRef, `${tableRef}_policies`, functionName],
              type: 'function_policy_cycle',
              description: `Function-Policy cycle: ${functionName}() queries ${tableRef} â†’ ${tableRef} policies call ${functionName}()`,
              function: functionName,
              table: tableRef,
              policy: policy.name,
              severity: 'critical'
            });
          }
        }
      }
    }
  }

  /**
   * Generate a visual dependency map
   */
  generateDependencyMap() {
    const map = {
      nodes: [],
      edges: [],
      clusters: {},
      circularReferences: this.circularPaths
    };

    // Add table nodes
    for (const [tableName, dependencies] of this.dependencies) {
      const policyCount = (this.policies.get(tableName) || []).length;
      const hasCircularRef = this.circularPaths.some(cycle => 
        cycle.cycle.includes(tableName)
      );

      map.nodes.push({
        id: tableName,
        type: 'table',
        label: `${tableName}\n(${policyCount} policies)`,
        policyCount: policyCount,
        hasCircularReference: hasCircularRef,
        color: hasCircularRef ? '#ff4444' : '#4444ff'
      });

      // Add edges for dependencies
      for (const dep of dependencies) {
        map.edges.push({
          from: tableName,
          to: dep,
          type: 'table_dependency',
          label: 'depends on'
        });
      }
    }

    // Add function nodes
    for (const [functionName, functionInfo] of this.functions) {
      const hasCircularRef = this.circularPaths.some(cycle => 
        cycle.function === functionName
      );

      map.nodes.push({
        id: functionName,
        type: 'function',
        label: `${functionName}()\n${functionInfo.tableReferences.length} table refs`,
        hasCircularReference: hasCircularRef,
        color: hasCircularRef ? '#ff8844' : '#44ff44'
      });

      // Add edges for function table references
      for (const tableRef of functionInfo.tableReferences) {
        map.edges.push({
          from: functionName,
          to: tableRef,
          type: 'function_table_reference',
          label: 'queries'
        });
      }
    }

    return map;
  }

  /**
   * Generate a Mermaid diagram of the dependencies
   */
  generateMermaidDiagram() {
    let mermaid = 'graph TD\n';
    
    // Add table nodes
    for (const [tableName, dependencies] of this.dependencies) {
      const hasCircularRef = this.circularPaths.some(cycle => 
        cycle.cycle.includes(tableName)
      );
      
      const nodeStyle = hasCircularRef ? ':::error' : ':::table';
      mermaid += `    ${tableName}[${tableName}]${nodeStyle}\n`;
    }

    // Add function nodes
    for (const [functionName] of this.functions) {
      const hasCircularRef = this.circularPaths.some(cycle => 
        cycle.function === functionName
      );
      
      const nodeStyle = hasCircularRef ? ':::error' : ':::function';
      mermaid += `    ${functionName}((${functionName}))${nodeStyle}\n`;
    }

    // Add dependency edges
    for (const [tableName, dependencies] of this.dependencies) {
      for (const dep of dependencies) {
        mermaid += `    ${tableName} --> ${dep}\n`;
      }
    }

    // Add function edges
    for (const [functionName, functionInfo] of this.functions) {
      for (const tableRef of functionInfo.tableReferences) {
        mermaid += `    ${functionName} -.-> ${tableRef}\n`;
      }
    }

    // Add circular reference highlighting
    for (const circularRef of this.circularPaths) {
      if (circularRef.type === 'function_policy_cycle') {
        mermaid += `    ${circularRef.function} -.->|CIRCULAR| ${circularRef.table}\n`;
        mermaid += `    ${circularRef.table} -.->|CIRCULAR| ${circularRef.function}\n`;
      }
    }

    // Add styles
    mermaid += '\n    classDef table fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n';
    mermaid += '    classDef function fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n';
    mermaid += '    classDef error fill:#ffebee,stroke:#b71c1c,stroke-width:3px\n';

    return mermaid;
  }

  /**
   * Generate a comprehensive report
   */
  generateReport() {
    const dependencyMap = this.generateDependencyMap();
    const mermaidDiagram = this.generateMermaidDiagram();

    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalTables: this.dependencies.size,
        totalFunctions: this.functions.size,
        totalCircularReferences: this.circularPaths.length,
        criticalIssues: this.circularPaths.filter(c => c.severity === 'critical').length
      },
      circularReferences: this.circularPaths,
      dependencyMap: dependencyMap,
      mermaidDiagram: mermaidDiagram,
      detailedAnalysis: this.generateDetailedAnalysis()
    };

    return report;
  }

  /**
   * Generate detailed analysis of each circular reference
   */
  generateDetailedAnalysis() {
    const analysis = [];

    for (const circularRef of this.circularPaths) {
      if (circularRef.type === 'function_policy_cycle') {
        const functionInfo = this.functions.get(circularRef.function);
        const tablePolicies = this.policies.get(circularRef.table) || [];
        
        analysis.push({
          type: 'Function-Policy Circular Reference',
          severity: circularRef.severity || 'high',
          function: circularRef.function,
          table: circularRef.table,
          description: circularRef.description,
          functionBody: functionInfo ? functionInfo.body : 'Unknown',
          affectedPolicies: tablePolicies.filter(p => 
            `${p.usingClause || ''} ${p.withCheckClause || ''}`.includes(`${circularRef.function}(`)
          ).map(p => p.name),
          recommendation: `Replace ${circularRef.function}() calls in ${circularRef.table} policies with direct column checks or auth.uid() comparisons`
        });
      }
    }

    return analysis;
  }

  /**
   * Run the complete dependency mapping analysis
   */
  async run() {
    console.log('ğŸ—ºï¸  Starting Policy Dependency Mapping...\n');
    
    const analysisReport = this.loadAnalysisReport();
    this.extractFunctions();
    this.findCircularDependencies();
    
    const report = this.generateReport();
    
    // Save reports
    const reportPath = path.join(__dirname, '..', 'policy-dependency-map.json');
    const mermaidPath = path.join(__dirname, '..', 'policy-dependency-diagram.mmd');
    
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    fs.writeFileSync(mermaidPath, report.mermaidDiagram);
    
    console.log('ğŸ“Š Dependency Mapping Complete!\n');
    console.log('='.repeat(60));
    console.log('DEPENDENCY ANALYSIS SUMMARY');
    console.log('='.repeat(60));
    console.log(`Total Tables: ${report.summary.totalTables}`);
    console.log(`Total Functions: ${report.summary.totalFunctions}`);
    console.log(`Circular References: ${report.summary.totalCircularReferences}`);
    console.log(`Critical Issues: ${report.summary.criticalIssues}`);
    
    if (report.circularReferences.length > 0) {
      console.log('\nğŸš¨ CIRCULAR REFERENCES DETECTED:');
      for (const ref of report.circularReferences) {
        const severity = ref.severity ? `[${ref.severity.toUpperCase()}]` : '[HIGH]';
        console.log(`   ${severity} ${ref.description}`);
      }
    }
    
    if (report.detailedAnalysis.length > 0) {
      console.log('\nğŸ” DETAILED ANALYSIS:');
      for (const analysis of report.detailedAnalysis) {
        console.log(`\n   ${analysis.type} - ${analysis.severity.toUpperCase()}`);
        console.log(`   Function: ${analysis.function}`);
        console.log(`   Table: ${analysis.table}`);
        console.log(`   Affected Policies: ${analysis.affectedPolicies.join(', ')}`);
        console.log(`   Recommendation: ${analysis.recommendation}`);
      }
    }
    
    console.log(`\nğŸ“„ Dependency map saved to: ${reportPath}`);
    console.log(`ğŸ“Š Mermaid diagram saved to: ${mermaidPath}`);
    console.log('\nğŸ’¡ To visualize the Mermaid diagram:');
    console.log('   1. Copy the contents of policy-dependency-diagram.mmd');
    console.log('   2. Paste into https://mermaid.live/');
    console.log('   3. View the interactive dependency graph');
    
    return report;
  }
}

// Run the dependency mapping if this script is executed directly
const mapper = new PolicyDependencyMapper();
mapper.run().catch(console.error);

export default PolicyDependencyMapper;